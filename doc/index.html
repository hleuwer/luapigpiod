<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>ldoc</h1>


<h2>Contents</h2>
<ul>
<li><a href="#Tables">Tables</a></li>
<li><a href="#Class_cWave">Class cWave </a></li>
<li><a href="#Class_cScript">Class cScript </a></li>
<li><a href="#Class_cCallback">Class cCallback </a></li>
<li><a href="#Class_cEventCallback">Class cEventCallback </a></li>
<li><a href="#Class_cNotify">Class cNotify </a></li>
<li><a href="#Class_cSerial_">Class cSerial. </a></li>
<li><a href="#Class_cI2C">Class cI2C </a></li>
<li><a href="#Class_cI2Cbb">Class cI2Cbb </a></li>
<li><a href="#Class_cSPI">Class cSPI </a></li>
<li><a href="#Class_cSPIbb">Class cSPIbb </a></li>
<li><a href="#Class_cSerialRead">Class cSerialRead </a></li>
<li><a href="#Class_cFile">Class cFile </a></li>
<li><a href="#Class_cI2CSlave">Class cI2CSlave </a></li>
<li><a href="#Class_cSession">Class cSession </a></li>
<li><a href="#Class_spiFlags">Class spiFlags </a></li>
<li><a href="#Module_functions">Module functions </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>pigpiod</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>pigpiod</code></h1>
<p>A Lua wrapper for the pigpiod C interface.</p>
<p>
 Luapigpiod allows control of Raspberry Pi GPIO pins from userspace.
 All operation are handled in the context of sessions (aka connections) or
 in the context of subusidiary classes like waves, scripts, callbacks,
 eventCallback, I2C, Serial or SPI devices.
 Multiple sessions and thus multiple sets of GPIO pins or interfaces (one set
 per session) are supported.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: (c) Herbert Leuwer, 2018</li>
        <li><strong>License</strong>: MIT</li>
        <li><strong>Author</strong>: Herbert Leuwer</li>
    </ul>


<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#_G._PIGPIOD_SESSIONS">_G._PIGPIOD_SESSIONS</a></td>
	<td class="summary">Active sessions are maintained in a global table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#_G._PIGPIOD_WAVEFORMS">_G._PIGPIOD_WAVEFORMS</a></td>
	<td class="summary">Active waveforms are maintained in a global table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#baudrates">baudrates</a></td>
	<td class="summary">Supported baudrates serial built-in serial interface.</td>
	</tr>
</table>
<h2><a href="#Class_cWave">Class cWave </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cWave.close">cWave.close (self)</a></td>
	<td class="summary">Close given waveform.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cWave.sendOnce">cWave.sendOnce (self)</a></td>
	<td class="summary">Send waveform once.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cWave.sendRepeat">cWave.sendRepeat (self)</a></td>
	<td class="summary">Send waveform repeatedly until cancelled.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cWave.sendUsingMode">cWave.sendUsingMode (self, mode)</a></td>
	<td class="summary">Send the given waveform with given mode.</td>
	</tr>
</table>
<h2><a href="#Class_cScript">Class cScript </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cScript.run">cScript.run (self, param)</a></td>
	<td class="summary">Run a script.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cScript.update">cScript.update (self, param)</a></td>
	<td class="summary">Update parameters of a script, which may already run.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cScript.status">cScript.status (self)</a></td>
	<td class="summary">Retrieve the run status and the parameters of given script.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cScript.stop">cScript.stop (self)</a></td>
	<td class="summary">Stop the given  running script.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cScript.delete">cScript.delete (self)</a></td>
	<td class="summary">Delete the given script.</td>
	</tr>
</table>
<h2><a href="#Class_cCallback">Class cCallback </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cCallback.cancel">cCallback.cancel (self)</a></td>
	<td class="summary">Cancel callback.</td>
	</tr>
</table>
<h2><a href="#Class_cEventCallback">Class cEventCallback </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cEventCallback.cancel">cEventCallback.cancel (self)</a></td>
	<td class="summary">Cancel event callback.</td>
	</tr>
</table>
<h2><a href="#Class_cNotify">Class cNotify </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cNotify.begin">cNotify.begin (self, bits)</a></td>
	<td class="summary">Start notification operation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cNotify.pause">cNotify.pause (self)</a></td>
	<td class="summary">Pause notification monitoring.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cNotify.decode">cNotify.decode (self, s)</a></td>
	<td class="summary">Convert a notification sample given in binary coded form in a Lua string
 into a table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cNotify.close">cNotify.close (self)</a></td>
	<td class="summary">Close notification channel.</td>
	</tr>
</table>
<h2><a href="#Class_cSerial_">Class cSerial. </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cSerial.close">cSerial.close (self)</a></td>
	<td class="summary">Close serial device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSerial.writeByte">cSerial.writeByte (self, val)</a></td>
	<td class="summary">Write a single byte to serial interface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSerial.readByte">cSerial.readByte (self)</a></td>
	<td class="summary">Read a single byte from serial interface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSerial.write">cSerial.write (self, data)</a></td>
	<td class="summary">Write data to serial interface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSerial.read">cSerial.read (self, nbytes)</a></td>
	<td class="summary">Read data from serial interface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSerial.dataAvailable">cSerial.dataAvailable (self)</a></td>
	<td class="summary">Check whether data is available in the bufffer.</td>
	</tr>
</table>
<h2><a href="#Class_cI2C">Class cI2C </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cI2C.close">cI2C.close (self)</a></td>
	<td class="summary">Close the given I2C device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.writeQuick">cI2C.writeQuick (self, bit)</a></td>
	<td class="summary">Send a single bit (0 or 1) via the given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.sendByte">cI2C.sendByte (self, byte)</a></td>
	<td class="summary">Send a byte via the given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.receiveByte">cI2C.receiveByte (self)</a></td>
	<td class="summary">Receive  a byte via given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.writeByte">cI2C.writeByte (self, reg, byte)</a></td>
	<td class="summary">Write the given byte to the given register in given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.writeWord">cI2C.writeWord (self, reg, word)</a></td>
	<td class="summary">Write the given 16 bit word to the given register in given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.readByte">cI2C.readByte (self, reg)</a></td>
	<td class="summary">Read a byte from the given register in given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.readWord">cI2C.readWord (self, reg)</a></td>
	<td class="summary">Read a 16 bit word from the given register in given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.processCall">cI2C.processCall (self, reg, val)</a></td>
	<td class="summary">Write + read (process) given 16 bit value to/freom given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.writeBlockData">cI2C.writeBlockData (self, reg, data)</a></td>
	<td class="summary">Write a block of bytes into given register of given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.readBlockData">cI2C.readBlockData (self, reg)</a></td>
	<td class="summary">Read a block of bytes from given register of given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.blockProcessCall">cI2C.blockProcessCall (self, reg, data)</a></td>
	<td class="summary">Send + receive a block of data to/from given register in given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.writeI2CBlockData">cI2C.writeI2CBlockData (self, reg, data)</a></td>
	<td class="summary">Write 1 to 32 bytes to given register on given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.readI2CBlockData">cI2C.readI2CBlockData (self, reg, nbytes)</a></td>
	<td class="summary">Read given number of bytes from given register in given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.readDevice">cI2C.readDevice (self, nbytes)</a></td>
	<td class="summary">Read given number bytes from given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.writeDevice">cI2C.writeDevice (self, data)</a></td>
	<td class="summary">Write given data to given device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2C.zip">cI2C.zip (self, inbuf, outlen)</a></td>
	<td class="summary">Execute a sequence of I2C commands.</td>
	</tr>
</table>
<h2><a href="#Class_cI2Cbb">Class cI2Cbb </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cI2Cbb.close">cI2Cbb.close (self)</a></td>
	<td class="summary">Close I2C bit bang device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2Cbb.zip">cI2Cbb.zip (self, inbuf, outlen)</a></td>
	<td class="summary">Execute a sequence of I2C commands.</td>
	</tr>
</table>
<h2><a href="#Class_cSPI">Class cSPI </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cSPI.close">cSPI.close (self)</a></td>
	<td class="summary">Close SPI device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSPI.read">cSPI.read (self, nbytes)</a></td>
	<td class="summary">Read given number of bytes from SPI interface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSPI.write">cSPI.write (self, data)</a></td>
	<td class="summary">Write given data to SPI interface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSPI.transfer">cSPI.transfer (self, data)</a></td>
	<td class="summary">Transfer (write and read) given data.</td>
	</tr>
</table>
<h2><a href="#Class_cSPIbb">Class cSPIbb </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cSPIbb.close">cSPIbb.close (self)</a></td>
	<td class="summary">Close SPI bit banging device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSPIbb.transfer">cSPIbb.transfer (self, data)</a></td>
	<td class="summary">Transfer (write and read) given data.</td>
	</tr>
</table>
<h2><a href="#Class_cSerialRead">Class cSerialRead </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cSerialRead.close">cSerialRead.close (self)</a></td>
	<td class="summary">Close serial read bit banging device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSerialRead.read">cSerialRead.read (self, nbytes)</a></td>
	<td class="summary">Read data from serial read bit banging device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSerialRead.invert">cSerialRead.invert (self, invert)</a></td>
	<td class="summary">Invert data read from serial read bit banging device.</td>
	</tr>
</table>
<h2><a href="#Class_cFile">Class cFile </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cFile.close">cFile.close (self)</a></td>
	<td class="summary">Close the file associated with given file object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cFile.read">cFile.read (self, nbytes)</a></td>
	<td class="summary">Read the given number of bytes from the file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cFile.write">cFile.write (self, data)</a></td>
	<td class="summary">Write the given data to the file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cFile.seek">cFile.seek (self, offset, from)</a></td>
	<td class="summary">Seeks into the file at position defined by offset and from.</td>
	</tr>
</table>
<h2><a href="#Class_cI2CSlave">Class cI2CSlave </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cI2CSlave.close">cI2CSlave.close (self)</a></td>
	<td class="summary">Close the given I2C device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2CSlave.transfer">cI2CSlave.transfer (self, data)</a></td>
	<td class="summary">Transfer data as I2C slave.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cI2CSlave.convertStatus">cI2CSlave.convertStatus (self, status)</a></td>
	<td class="summary">Convert binary status into a table.</td>
	</tr>
</table>
<h2><a href="#Class_cSession">Class cSession </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cSession.close">cSession.close (self)</a></td>
	<td class="summary">Close session.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.setMode">cSession.setMode (self, pin, mode)</a></td>
	<td class="summary">Set pin mode.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.getMode">cSession.getMode (self, pin)</a></td>
	<td class="summary">Get pin mode.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.setPullUpDown">cSession.setPullUpDown (self, pin, pud)</a></td>
	<td class="summary">Set pull-up/down configuration of pin.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.read">cSession.read (self, pin)</a></td>
	<td class="summary">Read pin level.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.write">cSession.write (self, pin, val)</a></td>
	<td class="summary">Write pin level.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.setPwmDutycycle">cSession.setPwmDutycycle (self, pin, dutycycle)</a></td>
	<td class="summary">Start Software controlled PWM on given pin.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.getPwmDutycycle">cSession.getPwmDutycycle (self, pin)</a></td>
	<td class="summary">Get the PWM duty cycle.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.setPwmRange">cSession.setPwmRange (self, pin, range)</a></td>
	<td class="summary">Set the dutycycle range for PWM on given pin.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.getPwmRange">cSession.getPwmRange (self, pin)</a></td>
	<td class="summary">Get current PWM range for given pin.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.getPwmRealRange">cSession.getPwmRealRange (self, pin)</a></td>
	<td class="summary">Get current PWM real range for given pin.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.setPwmFrequency">cSession.setPwmFrequency (self, pin, frequency)</a></td>
	<td class="summary">Set PWM frequency.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.getPwmFrequency">cSession.getPwmFrequency (self, pin)</a></td>
	<td class="summary">Get PWM frequency.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.setServoPulsewidth">cSession.setServoPulsewidth (self, pin, pulsewidth)</a></td>
	<td class="summary">Start servo pulses.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.getServoPulsewidth">cSession.getServoPulsewidth (self, pin)</a></td>
	<td class="summary">Get servo pulsewidth.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openNotify">cSession.openNotify (self)</a></td>
	<td class="summary">Open a notification channel.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.setWatchdog">cSession.setWatchdog (self, pin, timeout)</a></td>
	<td class="summary">Set watchdog for the specified pin.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.setGlitchFilter">cSession.setGlitchFilter (self, pin, steady)</a></td>
	<td class="summary">Set glitch filter for given pin.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openWave">cSession.openWave (self, waveform, name)</a></td>
	<td class="summary">Open a waveform as defined by parameter 'waveform'.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.waveClear">cSession.waveClear (self)</a></td>
	<td class="summary">Clear all waveforms.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.waveChain">cSession.waveChain (self, list)</a></td>
	<td class="summary">Define and start a chain of waveforms.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openScript">cSession.openScript (self, code)</a></td>
	<td class="summary">Open a gpiod script.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.callback">cSession.callback (self, pin, edge, func, userdata)</a></td>
	<td class="summary">Define a pin event callback function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.waitEdge">cSession.waitEdge (self, pin, edge, timeout)</a></td>
	<td class="summary">Wait for an edge to occur.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.getPadStrength">cSession.getPadStrength (self, pad)</a></td>
	<td class="summary">Get a pads signal strength in mA.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.setPadStrength">cSession.setPadStrength (self, pad, mamps)</a></td>
	<td class="summary">Set strength of a pad.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.shell">cSession.shell (self, name, scriptparam)</a></td>
	<td class="summary">Execute a shell script  on connected host.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openSerial">cSession.openSerial (self, baud, tty, name)</a></td>
	<td class="summary">Open serial device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openI2C">cSession.openI2C (self, bus, address, name)</a></td>
	<td class="summary">Open I2C device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.scanI2C">cSession.scanI2C (self, bus)</a></td>
	<td class="summary">Scan an I2C bus for present devices.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openSPI">cSession.openSPI (self, spichannel, bitrate, flags, name)</a></td>
	<td class="summary">Open SPI device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openSerialRead">cSession.openSerialRead (self, rxd, baud, name)</a></td>
	<td class="summary">Open serial read-only bit banging device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openI2Cbb">cSession.openI2Cbb (self, sda, scl, baud, name)</a></td>
	<td class="summary">Open I2C bit banging device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openSPIbb">cSession.openSPIbb (self, cs, miso, mosi, sclk, bitrate, flags, name)</a></td>
	<td class="summary">Open SPI bit banging device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openFile">cSession.openFile (self, filename, mode, name)</a></td>
	<td class="summary">Open a file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.listFiles">cSession.listFiles (self, pattern)</a></td>
	<td class="summary">Retrieve a list of files matching the given pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cSession.openI2CSlave">cSession.openI2CSlave (self, address, name)</a></td>
	<td class="summary">Open I2C Slave device.</td>
	</tr>
</table>
<h2><a href="#Class_spiFlags">Class spiFlags </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#spiFlags:mode">spiFlags:mode (pol, pha)</a></td>
	<td class="summary">SPI Mode: 0..3 => 00, 01, 10, 11 = (pol, pha)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#spiFlags:cslev">spiFlags:cslev (cs2, cs1, cs0)</a></td>
	<td class="summary">SPI chip select level: 0..7 => 000, 001, ..., 111 = (cs2, cs1, cs0)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#spiFlags:csuse">spiFlags:csuse (cs2, cs1, cs0)</a></td>
	<td class="summary">SPI chip select usage: 0..7 => 000, 001, ..., 111 = (cs2, cs1, cs0)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#spiFlags:interface">spiFlags:interface (val)</a></td>
	<td class="summary">SPI interface: "aux" or "main"</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#spiFlags:wires">spiFlags:wires (val)</a></td>
	<td class="summary">SPI 3 wire: 3 or 4</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#spiFlags:masterbytes">spiFlags:masterbytes (val)</a></td>
	<td class="summary">SPI MOSI bytes to transmit before changing to MISO: 0..15</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#spiFlags:txendian">spiFlags:txendian (val)</a></td>
	<td class="summary">SPI transmit endianess: "big" or "little"</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#spiFlags:rxendian">spiFlags:rxendian (val)</a></td>
	<td class="summary">SPI receive endianess: "big" or "little"</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#spiFlags:wordsize">spiFlags:wordsize (val)</a></td>
	<td class="summary">SPI word size: 0 => 1 Byte, 1..8 => 8 bits per char, 9..16 => 16 bits per char, 32 bits per char</td>
	</tr>
</table>
<h2><a href="#Module_functions">Module functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#open">open (host, port, name)</a></td>
	<td class="summary">Open a session with given host on given port.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wait">wait (t, ts)</a></td>
	<td class="summary">Wait for a while.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#busyWait">busyWait (t)</a></td>
	<td class="summary">Busy wait for a while.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#info">info ()</a></td>
	<td class="summary">Returns info string.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#getEventStats">getEventStats ()</a></td>
	<td class="summary">Get event handling statistics in the form.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#clearEventStats">clearEventStats ()</a></td>
	<td class="summary">Clear event statistics.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#startThread">startThread (code, name, ...)</a></td>
	<td class="summary">Start a new thrad.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#stopThread">stopThread (pthread)</a></td>
	<td class="summary">Stop given thread.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Tables"></a>Tables</h2>

    <dl class="function">
    <dt>
    <a name = "_G._PIGPIOD_SESSIONS"></a>
    <strong>_G._PIGPIOD_SESSIONS</strong>
    </dt>
    <dd>
    Active sessions are maintained in a global table.
 Used to retrieve session object from handle in callbacks and for finalization
 during object garbage collection.







</dd>
    <dt>
    <a name = "_G._PIGPIOD_WAVEFORMS"></a>
    <strong>_G._PIGPIOD_WAVEFORMS</strong>
    </dt>
    <dd>
    Active waveforms are maintained in a global table.
 Used to retrieve session object from handle in callbacks and for finalization
 during object garbage collection.







</dd>
    <dt>
    <a name = "baudrates"></a>
    <strong>baudrates</strong>
    </dt>
    <dd>
    Supported baudrates serial built-in serial interface.
 9600 (1), 19200 (2), 38400 (3), 57600 (4), 115200 (5), 230400 (6).


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">1</span>
         9600 bps
        </li>
        <li><span class="parameter">2</span>
         19200 bps
        </li>
        <li><span class="parameter">3</span>
         38400 bps
        </li>
        <li><span class="parameter">4</span>
         57600 bps
        </li>
        <li><span class="parameter">5</span>
         115200 bps
        </li>
        <li><span class="parameter">6</span>
         230400 bps
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cWave"></a>Class cWave </h2>

          <div class="section-description">
          <h3>Waveforms</h3>
 Waveforms allow to define waveforms to be output on a number of
 GPIO pins in a programmable way.  Once defined the waveform can be sent
 once or repeatedly.<br>
 Constructor: <code>session:openWave(waveform, name)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cWave.close"></a>
    <strong>cWave.close (self)</strong>
    </dt>
    <dd>
    Close given waveform.
<p> This will delete all waveforms intermediately stored.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Waveform.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cWave.sendOnce"></a>
    <strong>cWave.sendOnce (self)</strong>
    </dt>
    <dd>
    Send waveform once.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Waveform.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Number of DMA block in waveform.
    </ol>




</dd>
    <dt>
    <a name = "cWave.sendRepeat"></a>
    <strong>cWave.sendRepeat (self)</strong>
    </dt>
    <dd>
    Send waveform repeatedly until cancelled.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Waveform.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Number of DMA blocks.
    </ol>




</dd>
    <dt>
    <a name = "cWave.sendUsingMode"></a>
    <strong>cWave.sendUsingMode (self, mode)</strong>
    </dt>
    <dd>
    Send the given waveform with given mode.
<p> The mode is by a textstring:<br>
 'oneshot', 'repeat', 'oneshotsync', 'repeatsync'


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Waveform.
        </li>
        <li><span class="parameter">mode</span>
         Mode to be used for sending.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Number of DMA blocks.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cScript"></a>Class cScript </h2>

          <div class="section-description">
          <h3>Scripting</h3>
 A script is a  microcode program to be executed in a specialized virtual
 machine in the pigpiod daemon.
 They allow very high pin toggling rates.
 See <a href=http://abyz.me.uk/rpi/pigpio/pigs.html#Scripts> Scripting </a><br>
 Constructor: <code>script=session:openScript(code, name)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cScript.run"></a>
    <strong>cScript.run (self, param)</strong>
    </dt>
    <dd>
    Run a script.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Script.
        </li>
        <li><span class="parameter">param</span>
         List of up to 10 parameters for the script.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cScript.update"></a>
    <strong>cScript.update (self, param)</strong>
    </dt>
    <dd>
    Update parameters of a script, which may already run.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Script.
        </li>
        <li><span class="parameter">param</span>
         List of up to 10 parameters replacing the corresponding
              subset of previous parameters.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cScript.status"></a>
    <strong>cScript.status (self)</strong>
    </dt>
    <dd>
    Retrieve the run status and the parameters of given script.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Script.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Run status and list of parameters on success; nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cScript.stop"></a>
    <strong>cScript.stop (self)</strong>
    </dt>
    <dd>
    Stop the given  running script.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Script.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cScript.delete"></a>
    <strong>cScript.delete (self)</strong>
    </dt>
    <dd>
    Delete the given script.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Script.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cCallback"></a>Class cCallback </h2>

          <div class="section-description">
          <h3>Pin event callback</h3>
 Callbacks are executed when a the state of a certain pin changes.  If a
 watchdog is configured on the pin, the callback is also called with a pseudo
 level indication.<br>
 Constructor: <code>cb=session:callback(pin, edge, func, userdata)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cCallback.cancel"></a>
    <strong>cCallback.cancel (self)</strong>
    </dt>
    <dd>
    Cancel callback.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Callback.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cEventCallback"></a>Class cEventCallback </h2>

          <div class="section-description">
          <h3>User initiated event callback</h3>
 Up to 32 event (0 to 31) are supported.<br>
 Constructor: <code>cb=session:eventCallback(event, func, userdata)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cEventCallback.cancel"></a>
    <strong>cEventCallback.cancel (self)</strong>
    </dt>
    <dd>
    Cancel event callback.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Eventcallback
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cNotify"></a>Class cNotify </h2>

          <div class="section-description">
          <h3>Notification channels</h3>
 Notification channels record pin changes in a FIFO which is readable by a
 file.<br>
 Constructor:<code>notify=session:openNotify()</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cNotify.begin"></a>
    <strong>cNotify.begin (self, bits)</strong>
    </dt>
    <dd>
    Start notification operation.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Notification channel.
        </li>
        <li><span class="parameter">bits</span>
         Bitmask defining the GPIOs to monitor.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cNotify.pause"></a>
    <strong>cNotify.pause (self)</strong>
    </dt>
    <dd>
    Pause notification monitoring.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Notification channel.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cNotify.decode"></a>
    <strong>cNotify.decode (self, s)</strong>
    </dt>
    <dd>
    Convert a notification sample given in binary coded form in a Lua string
 into a table.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Notification channel.
        </li>
        <li><span class="parameter">s</span>
         Encoded notification sample.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Decoded notification sample as Lua table of form
 <code>{seqno=SEGNO, flags=FLAGS, tick=TICK, level=LEVEL}</code>
    </ol>




</dd>
    <dt>
    <a name = "cNotify.close"></a>
    <strong>cNotify.close (self)</strong>
    </dt>
    <dd>
    Close notification channel.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Notification channel.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cSerial_"></a>Class cSerial. </h2>

          <div class="section-description">
          <h3>Serial Device</h3>
 Serial (RS232) Devices.<br>
 Constructor:<code>device=session:openSerial(baud, tty)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cSerial.close"></a>
    <strong>cSerial.close (self)</strong>
    </dt>
    <dd>
    Close serial device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSerial.writeByte"></a>
    <strong>cSerial.writeByte (self, val)</strong>
    </dt>
    <dd>
    Write a single byte to serial interface.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">val</span>
         Value to write.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSerial.readByte"></a>
    <strong>cSerial.readByte (self)</strong>
    </dt>
    <dd>
    Read a single byte from serial interface.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Byte read on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSerial.write"></a>
    <strong>cSerial.write (self, data)</strong>
    </dt>
    <dd>
    Write data to serial interface.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">data</span>
         Data to send as Lua string.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSerial.read"></a>
    <strong>cSerial.read (self, nbytes)</strong>
    </dt>
    <dd>
    Read data from serial interface.  Up to nbytes are read.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">nbytes</span>
         Number of bytes to read.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Data read.
    </ol>




</dd>
    <dt>
    <a name = "cSerial.dataAvailable"></a>
    <strong>cSerial.dataAvailable (self)</strong>
    </dt>
    <dd>
    Check whether data is available in the bufffer.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Number of available data on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cI2C"></a>Class cI2C </h2>

          <div class="section-description">
          <h3>I2C Device</h3>
 This is a master I2C device.<br>
 Constructor: <code>dev=session:openI2C(bus, address, name)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cI2C.close"></a>
    <strong>cI2C.close (self)</strong>
    </dt>
    <dd>
    Close the given I2C device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        I2C interface instance as table.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.writeQuick"></a>
    <strong>cI2C.writeQuick (self, bit)</strong>
    </dt>
    <dd>
    Send a single bit (0 or 1) via the given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">bit</span>
         Bit to send.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.sendByte"></a>
    <strong>cI2C.sendByte (self, byte)</strong>
    </dt>
    <dd>
    Send a byte via the given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">byte</span>
         Byte to send.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cI2C.receiveByte"></a>
    <strong>cI2C.receiveByte (self)</strong>
    </dt>
    <dd>
    Receive  a byte via given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Byte received on success, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cI2C.writeByte"></a>
    <strong>cI2C.writeByte (self, reg, byte)</strong>
    </dt>
    <dd>
    Write the given byte to the given register in given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
        <li><span class="parameter">byte</span>
         Byte to write.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cI2C.writeWord"></a>
    <strong>cI2C.writeWord (self, reg, word)</strong>
    </dt>
    <dd>
    Write the given 16 bit word to the given register in given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
        <li><span class="parameter">word</span>
          Word to write.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cI2C.readByte"></a>
    <strong>cI2C.readByte (self, reg)</strong>
    </dt>
    <dd>
    Read a byte from the given register in given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Byte read on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.readWord"></a>
    <strong>cI2C.readWord (self, reg)</strong>
    </dt>
    <dd>
    Read a 16 bit word from the given register in given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Word read on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.processCall"></a>
    <strong>cI2C.processCall (self, reg, val)</strong>
    </dt>
    <dd>
    Write + read (process) given 16 bit value to/freom given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
        <li><span class="parameter">val</span>
         Word to write.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Value read on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.writeBlockData"></a>
    <strong>cI2C.writeBlockData (self, reg, data)</strong>
    </dt>
    <dd>
    Write a block of bytes into given register of given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
        <li><span class="parameter">data</span>
         Binary data stored in Lua string allowing embedded zeros.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Binary data from device on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.readBlockData"></a>
    <strong>cI2C.readBlockData (self, reg)</strong>
    </dt>
    <dd>
    Read a block of bytes from given register of given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Binary data stored in Lua string allowing embedded zeros on success
         nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.blockProcessCall"></a>
    <strong>cI2C.blockProcessCall (self, reg, data)</strong>
    </dt>
    <dd>
    Send + receive a block of data to/from given register in given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
        <li><span class="parameter">data</span>
         Lua string with data to be written.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Data read in a Lua string allowing embedded zeros.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.writeI2CBlockData"></a>
    <strong>cI2C.writeI2CBlockData (self, reg, data)</strong>
    </dt>
    <dd>
    Write 1 to 32 bytes to given register on given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
        <li><span class="parameter">data</span>
         Lua string with data to be written.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.readI2CBlockData"></a>
    <strong>cI2C.readI2CBlockData (self, reg, nbytes)</strong>
    </dt>
    <dd>
    Read given number of bytes from given register in given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">reg</span>
         Register number.
        </li>
        <li><span class="parameter">nbytes</span>
         Number of bytes to be read.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Number of byte read.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.readDevice"></a>
    <strong>cI2C.readDevice (self, nbytes)</strong>
    </dt>
    <dd>
    Read given number bytes from given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">nbytes</span>
         Number of bytes to be read.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Lua string with read data.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.writeDevice"></a>
    <strong>cI2C.writeDevice (self, data)</strong>
    </dt>
    <dd>
    Write given data to given device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">data</span>
         Lua string with data to write.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2C.zip"></a>
    <strong>cI2C.zip (self, inbuf, outlen)</strong>
    </dt>
    <dd>
    Execute a sequence of I2C commands.
 For details see <a href=http://abyz.me.uk/rpi/pigpio/pdif2.html#i2c_zip> I2C ZIP </a>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">inbuf</span>
         Lua String with data to be sent.
        </li>
        <li><span class="parameter">outlen</span>
         Number of Byte to be returned.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bytes read in a Lua string on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cI2Cbb"></a>Class cI2Cbb </h2>

          <div class="section-description">
          <h3>I2C Bit Banging Device</h3>
 This device is a GPIO based I2C device allowing special service primitives.
 Constructor: <code>dev=session:openI2Cbb(sda, scl, baud)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cI2Cbb.close"></a>
    <strong>cI2Cbb.close (self)</strong>
    </dt>
    <dd>
    Close I2C bit bang device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2Cbb.zip"></a>
    <strong>cI2Cbb.zip (self, inbuf, outlen)</strong>
    </dt>
    <dd>
    Execute a sequence of I2C commands.
 For details see <a href=http://abyz.me.uk/rpi/pigpio/pdif2.html#i2c_zip> I2C ZIP </a>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">inbuf</span>
         Lua String with data to be sent.
        </li>
        <li><span class="parameter">outlen</span>
         Number of Byte to be returned.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bytes read in a Lua string on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cSPI"></a>Class cSPI </h2>

          <div class="section-description">
          <h3>SPI Device</h3>
 This is a master SPI device.<br>
 Constructor: <code>dev=session:openSPI(spichannel, bitrate, flags, name)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cSPI.close"></a>
    <strong>cSPI.close (self)</strong>
    </dt>
    <dd>
    Close SPI device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Decvice.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cSPI.read"></a>
    <strong>cSPI.read (self, nbytes)</strong>
    </dt>
    <dd>
    Read given number of bytes from SPI interface.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">nbytes</span>
         Number of bytes to read.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Data read in Lua string, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSPI.write"></a>
    <strong>cSPI.write (self, data)</strong>
    </dt>
    <dd>
    Write given data to SPI interface.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">data</span>
         Data to write in a Lua string.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Number of byte written, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cSPI.transfer"></a>
    <strong>cSPI.transfer (self, data)</strong>
    </dt>
    <dd>
    Transfer (write and read) given data.
 The number of bytes read is equal to the number of bytes written.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">data</span>
         Data to write in a Lua string.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Data read in a Lua string on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cSPIbb"></a>Class cSPIbb </h2>

          <div class="section-description">
          <h3>SPI Bit Banging Device</h3>
 This is a master SPI device using any set of GPIO pins.<br>
 Constructor: <code>dev=session:openSPIbb(cs, mosi, miso, bitrate, flags, name)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cSPIbb.close"></a>
    <strong>cSPIbb.close (self)</strong>
    </dt>
    <dd>
    Close SPI bit banging device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Decvice.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cSPIbb.transfer"></a>
    <strong>cSPIbb.transfer (self, data)</strong>
    </dt>
    <dd>
    Transfer (write and read) given data.
 The number of bytes read is equal to the number of bytes written.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">data</span>
         Data to write in a Lua string.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Data read in a Lua string on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cSerialRead"></a>Class cSerialRead </h2>

          <div class="section-description">
          <h3>Serial Bit Banging Read Device</h3>
 This is a receive only serial device using any of GPIO pins.<br>
 Constructor: <code>dev=session:openSerialRead(pin, bitrage, name)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cSerialRead.close"></a>
    <strong>cSerialRead.close (self)</strong>
    </dt>
    <dd>
    Close serial read bit banging device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSerialRead.read"></a>
    <strong>cSerialRead.read (self, nbytes)</strong>
    </dt>
    <dd>
    Read data from serial read bit banging device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">nbytes</span>
         Number of bytes to read.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Data read in Lua string on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSerialRead.invert"></a>
    <strong>cSerialRead.invert (self, invert)</strong>
    </dt>
    <dd>
    Invert data read from serial read bit banging device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device
        </li>
        <li><span class="parameter">invert</span>
         0: do not invert, 1: do invert data.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cFile"></a>Class cFile </h2>

          <div class="section-description">
          <h3>Files</h3>
 File object allows managing storage in connected hosts.
 Constructor: <code>file=session:openFile(filename, mode, name)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cFile.close"></a>
    <strong>cFile.close (self)</strong>
    </dt>
    <dd>
    Close the file associated with given file object.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         File.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cFile.read"></a>
    <strong>cFile.read (self, nbytes)</strong>
    </dt>
    <dd>
    Read the given number of bytes from the file.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         File.
        </li>
        <li><span class="parameter">nbytes</span>
         Number of bytes to read.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Data read in Lua string on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cFile.write"></a>
    <strong>cFile.write (self, data)</strong>
    </dt>
    <dd>
    Write the given data to the file.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         File.
        </li>
        <li><span class="parameter">data</span>
         Data to be written.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cFile.seek"></a>
    <strong>cFile.seek (self, offset, from)</strong>
    </dt>
    <dd>
    Seeks into the file at position defined by offset and from.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         File.
        </li>
        <li><span class="parameter">offset</span>
         Byte offset (positive or negative) agains ref position in from.
        </li>
        <li><span class="parameter">from</span>
         Reference position:<br>
             gpio.FROM_START (0), gpio.FROM_CURRENT (1) or gpio.FROM_END (2)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        New file position of success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cI2CSlave"></a>Class cI2CSlave </h2>

          <div class="section-description">
          <h3>I2C Slave Device</h3>
 This is a slave I2C device.<br>
 Constructor: <code>dev=session:openI2CSlave(address, name)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cI2CSlave.close"></a>
    <strong>cI2CSlave.close (self)</strong>
    </dt>
    <dd>
    Close the given I2C device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        I2C Slave interface instance as table, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cI2CSlave.transfer"></a>
    <strong>cI2CSlave.transfer (self, data)</strong>
    </dt>
    <dd>
    Transfer data as I2C slave.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">data</span>
         Data to transfer
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

         Data received as Lua string plus
         status word (as table and number)  on success,
         nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cI2CSlave.convertStatus"></a>
    <strong>cI2CSlave.convertStatus (self, status)</strong>
    </dt>
    <dd>
    Convert binary status into a table.
<p> The table has the following components:
 <ul>
 <li> ncopy: Number of bytes copied to transmit fifo.
 <li> nrx, ntx: Number of bytes in recv/transmit fifo.
 <li> rxbusy, txbusy: Receiver/transmitter busy.
 <li> rxempty, txempty: Recv/transmit fifo empty.
 <li> rxfull, txfull: Recv/transmit fifo full.
 </ul>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Device.
        </li>
        <li><span class="parameter">status</span>
         Status to convert.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Status as table.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_cSession"></a>Class cSession </h2>

          <div class="section-description">
          All GPIO control and status operations occurs in the context of a session.
 A session is create by connecting to a remote Raspberry Pi instance via
 network or locally.<br>
 Constructor: <code>session=pigpiod.open(host, port, name)</code>
          </div>
    <dl class="function">
    <dt>
    <a name = "cSession.close"></a>
    <strong>cSession.close (self)</strong>
    </dt>
    <dd>
    Close session.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on error.
    </ol>




</dd>
    <dt>
    <a name = "cSession.setMode"></a>
    <strong>cSession.setMode (self, pin, mode)</strong>
    </dt>
    <dd>
    Set pin mode.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">mode</span>
         gpio.INPUT or gpio.OUTPUT.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        ture on success, nil + errormsg on error.
    </ol>




</dd>
    <dt>
    <a name = "cSession.getMode"></a>
    <strong>cSession.getMode (self, pin)</strong>
    </dt>
    <dd>
    Get pin mode.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on error.
    </ol>




</dd>
    <dt>
    <a name = "cSession.setPullUpDown"></a>
    <strong>cSession.setPullUpDown (self, pin, pud)</strong>
    </dt>
    <dd>
    Set pull-up/down configuration of pin.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">pud</span>
         gpio.PUD_UP, gpio.PUD_DOWN or gpio.PUD_OFF
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on error.
    </ol>




</dd>
    <dt>
    <a name = "cSession.read"></a>
    <strong>cSession.read (self, pin)</strong>
    </dt>
    <dd>
    Read pin level.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Pin level.
    </ol>




</dd>
    <dt>
    <a name = "cSession.write"></a>
    <strong>cSession.write (self, pin, val)</strong>
    </dt>
    <dd>
    Write pin level.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">val</span>
         Level to set, 0 or 1.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.setPwmDutycycle"></a>
    <strong>cSession.setPwmDutycycle (self, pin, dutycycle)</strong>
    </dt>
    <dd>
    Start Software controlled PWM on given pin.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">dutycycle</span>
         Dutycycle to use (0..range) default: 0..255.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.getPwmDutycycle"></a>
    <strong>cSession.getPwmDutycycle (self, pin)</strong>
    </dt>
    <dd>
    Get the PWM duty cycle.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Active dutycycle: 0..range
    </ol>




</dd>
    <dt>
    <a name = "cSession.setPwmRange"></a>
    <strong>cSession.setPwmRange (self, pin, range)</strong>
    </dt>
    <dd>
    Set the dutycycle range for PWM on given pin.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">range</span>
         Range between 25 and 40000.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success; nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cSession.getPwmRange"></a>
    <strong>cSession.getPwmRange (self, pin)</strong>
    </dt>
    <dd>
    Get current PWM range for given pin.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Dutycycle range for given pin.
    </ol>




</dd>
    <dt>
    <a name = "cSession.getPwmRealRange"></a>
    <strong>cSession.getPwmRealRange (self, pin)</strong>
    </dt>
    <dd>
    Get current PWM real range for given pin.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        PWM real range.
    </ol>




</dd>
    <dt>
    <a name = "cSession.setPwmFrequency"></a>
    <strong>cSession.setPwmFrequency (self, pin, frequency)</strong>
    </dt>
    <dd>
    Set PWM frequency.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">frequency</span>
         Frequency in Hz.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "cSession.getPwmFrequency"></a>
    <strong>cSession.getPwmFrequency (self, pin)</strong>
    </dt>
    <dd>
    Get PWM frequency.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Frequency in Hz.
    </ol>




</dd>
    <dt>
    <a name = "cSession.setServoPulsewidth"></a>
    <strong>cSession.setServoPulsewidth (self, pin, pulsewidth)</strong>
    </dt>
    <dd>
    Start servo pulses.  Can be alternatively called via cSession.servo(...).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">pulsewidth</span>
         Pulsewidth between 500 and 2500, default: 1500.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "cSession.getServoPulsewidth"></a>
    <strong>cSession.getServoPulsewidth (self, pin)</strong>
    </dt>
    <dd>
    Get servo pulsewidth.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Servo pulsewidth.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openNotify"></a>
    <strong>cSession.openNotify (self)</strong>
    </dt>
    <dd>
    Open a notification channel.
 Data can be read from file /dev/pigpio<handle> with <handle>
 as returned by this function.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Notifcation channel handle.
    </ol>




</dd>
    <dt>
    <a name = "cSession.setWatchdog"></a>
    <strong>cSession.setWatchdog (self, pin, timeout)</strong>
    </dt>
    <dd>
    Set watchdog for the specified pin.
 A timeout of 0 cancels the watchdog.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">timeout</span>
         Timeout in milliseconds.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.setGlitchFilter"></a>
    <strong>cSession.setGlitchFilter (self, pin, steady)</strong>
    </dt>
    <dd>
    Set glitch filter for given pin.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">steady</span>
         Minimum time of stable level in order to report state change.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openWave"></a>
    <strong>cSession.openWave (self, waveform, name)</strong>
    </dt>
    <dd>
    Open a waveform as defined by parameter 'waveform'.
<p> An optional user defined name can be provided. If nil, a name 'wave-<wave.handle>' is
 automatically created.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">waveform</span>
         List of waveforms in the following format:
 <ul>
 <li><code>{typ, WF1, WF2, ..., WFn}</code>.
 <li>typ is either 'generic' or 'serial'.
 <li>WFi is a table in one of the following formats:
 <ul>
 <li>generic: <code>{on=PINMASK, off=PINMASK, delay=TIME_in_us}</code>.
 <li>serial: <code>{baud=BAUDRATE, nbits=NBITS, stopbits=STOPBITS, timeoffs=TIME_in_us, STRING}</code>.
 </ul></ul>
        </li>
        <li><span class="parameter">name</span>
         Name of the waveform (optional).
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Wave objec on success; nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.waveClear"></a>
    <strong>cSession.waveClear (self)</strong>
    </dt>
    <dd>
    Clear all waveforms.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.waveChain"></a>
    <strong>cSession.waveChain (self, list)</strong>
    </dt>
    <dd>
    Define and start a chain of waveforms.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">list</span>
         Lua list with commands defining the chain.
 <ul>
 <li>Each list entry presents on line of a chain micro program.
 <li>Syntax:
 <li>table interpreted as wave object reference.
     <ul>
     <li>'delay m':                     delay m microseconds.
     <li>'start' ... 'repeat N':        repeat loop N times.
     <li>'start' ... 'repeat forever':  repeat forever.
 </ul></ul>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openScript"></a>
    <strong>cSession.openScript (self, code)</strong>
    </dt>
    <dd>
    Open a gpiod script.
 on gpiod scripting.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">code</span>
         Scipt code.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Script object on success; nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.callback"></a>
    <strong>cSession.callback (self, pin, edge, func, userdata)</strong>
    </dt>
    <dd>
    Define a pin event callback function.
 The callback function has the following signature:<br>
 <code>cbfunc(sess, pin, level, tick, [userdata])</code>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">edge</span>
         Type of edge:
        <code>gpio.RISING_EDGE, gpio.FALLING_EDGE, gpio.EITHER_EDGE</code>
        </li>
        <li><span class="parameter">func</span>
         Lua callback function.
        </li>
        <li><span class="parameter">userdata</span>
         Any Lua value as user parameter.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Callback object.
    </ol>




</dd>
    <dt>
    <a name = "cSession.waitEdge"></a>
    <strong>cSession.waitEdge (self, pin, edge, timeout)</strong>
    </dt>
    <dd>
    Wait for an edge to occur.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pin</span>
         GPIO number.
        </li>
        <li><span class="parameter">edge</span>
         Type of edge:
        <code>gpio.RISING_EDGE, gpio.FALLING_EDGE, gpio.EITHER_EDGE</code>
        </li>
        <li><span class="parameter">timeout</span>
         Timeout in seconds.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true if edge occured, nil + "timeout" if edge is not detected.
    </ol>




</dd>
    <dt>
    <a name = "cSession.getPadStrength"></a>
    <strong>cSession.getPadStrength (self, pad)</strong>
    </dt>
    <dd>
    Get a pads signal strength in mA.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pad</span>
         Pad (pin)
 <ul>
 <li>pad = 0: GPIO[0..27]
 <li>pad = 1: GPIO[28..45]
 <li>pad = 2: GPIO[46 .. 53]
 </ul>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Signal strength in mA.
    </ol>




</dd>
    <dt>
    <a name = "cSession.setPadStrength"></a>
    <strong>cSession.setPadStrength (self, pad, mamps)</strong>
    </dt>
    <dd>
    Set strength of a pad.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pad</span>
         Pad (pin)
 <ul>
 <li>pad = 0: GPIO[0..27]
 <li>pad = 1: GPIO[28..45]
 <li>pad = 2: GPIO[46 .. 53]
 </ul>
        </li>
        <li><span class="parameter">mamps</span>
         Strength in mA
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.shell"></a>
    <strong>cSession.shell (self, name, scriptparam)</strong>
    </dt>
    <dd>
    Execute a shell script  on connected host.
 The script name may contain '-' and '_' and alphanumeric characters.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">name</span>
         Name of the script.
        </li>
        <li><span class="parameter">scriptparam</span>
         Parameters for the script.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 on success, nil + error message on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openSerial"></a>
    <strong>cSession.openSerial (self, baud, tty, name)</strong>
    </dt>
    <dd>
    Open serial device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">baud</span>
         Baudrate in bits per second.
        </li>
        <li><span class="parameter">tty</span>
         Serial device file name starting with
            /dev/serial or /dev/tty
        </li>
        <li><span class="parameter">name</span>
         Name of the device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Device object on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openI2C"></a>
    <strong>cSession.openI2C (self, bus, address, name)</strong>
    </dt>
    <dd>
    Open I2C device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">bus</span>
         Bus index.
        </li>
        <li><span class="parameter">address</span>
         Address of the device.
        </li>
        <li><span class="parameter">name</span>
         Optional name.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        I2C device object; nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.scanI2C"></a>
    <strong>cSession.scanI2C (self, bus)</strong>
    </dt>
    <dd>
    Scan an I2C bus for present devices.
 Returns a list of table in the following form:
 <code>{{addr=ADDR, status="ok"|"used", data=DATA}, ... {addr, ...}}</code>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">bus</span>
         Bus index 0 or 1.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        List of connect and usable or not usable devices on success,
         nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openSPI"></a>
    <strong>cSession.openSPI (self, spichannel, bitrate, flags, name)</strong>
    </dt>
    <dd>
    Open SPI device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">spichannel</span>
         Channel (chip select) to use: 0..2 - default: 0.
        </li>
        <li><span class="parameter">bitrate</span>
         Bitrate 32 kbps to 30 Mbps - default: 32 kbps.
        </li>
        <li><span class="parameter">flags</span>
         Flags to control basic parameters of the device.
        </li>
        <li><span class="parameter">name</span>
         Name for device - default: spidev-<SPIHANDLE>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Device object on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openSerialRead"></a>
    <strong>cSession.openSerialRead (self, rxd, baud, name)</strong>
    </dt>
    <dd>
    Open serial read-only bit banging device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">rxd</span>
         Number of GPIO pio to use as RxD pin.
        </li>
        <li><span class="parameter">baud</span>
         Bitrage in bps.
        </li>
        <li><span class="parameter">name</span>
         Name of device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Instance of serial read device on success, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "cSession.openI2Cbb"></a>
    <strong>cSession.openI2Cbb (self, sda, scl, baud, name)</strong>
    </dt>
    <dd>
    Open I2C bit banging device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">sda</span>
         GPIO number of pin used for SDA.
        </li>
        <li><span class="parameter">scl</span>
         GPIO number of pin used for SCL.
        </li>
        <li><span class="parameter">baud</span>
         Bitrate
        </li>
        <li><span class="parameter">name</span>
         Name of device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Instance of I2C bit banging device, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openSPIbb"></a>
    <strong>cSession.openSPIbb (self, cs, miso, mosi, sclk, bitrate, flags, name)</strong>
    </dt>
    <dd>
    Open SPI bit banging device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">cs</span>
         GPIO number to use for chip select CS.
        </li>
        <li><span class="parameter">miso</span>
         GPIO number to use for master-in-slave-out MISO.
        </li>
        <li><span class="parameter">mosi</span>
         GPIO number to use for master-out-slave-in MOSI.
        </li>
        <li><span class="parameter">sclk</span>
         GPIO number to use for serial clock SCLK.
        </li>
        <li><span class="parameter">bitrate</span>
         Bitrate 32 kbps to 30 Mbps - default: 32 kbps.
        </li>
        <li><span class="parameter">flags</span>
         Flags to control basic parameters of the device.
        </li>
        <li><span class="parameter">name</span>
         Name for device - default: spibbdev-<SPIHANDLE>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Device object on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openFile"></a>
    <strong>cSession.openFile (self, filename, mode, name)</strong>
    </dt>
    <dd>
    Open a file.
<p> A file can be opened in the follwoing modes:<br>
 <ul>
 <li> FILE_READ, FILE_WRITE, FILE_RW optionally or'd with one of the following
 <li> FILE_APPEND, FILE_CREATE, FILE_TRUNC
 </ul>
 Note: Newly created file will have root as the owner
       with owner write permission.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">filename</span>
         Filename.
        </li>
        <li><span class="parameter">mode</span>
         Filemode.
        </li>
        <li><span class="parameter">name</span>
         Optional name for the file object.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        File object on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.listFiles"></a>
    <strong>cSession.listFiles (self, pattern)</strong>
    </dt>
    <dd>
    Retrieve a list of files matching the given pattern.
 The pattern must match an entry in <code>/opt/pigpio/access</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">pattern</span>
         Pattern used for file search.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        List with file names, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "cSession.openI2CSlave"></a>
    <strong>cSession.openI2CSlave (self, address, name)</strong>
    </dt>
    <dd>
    Open I2C Slave device.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Session.
        </li>
        <li><span class="parameter">address</span>
         I2C address.
        </li>
        <li><span class="parameter">name</span>
         Name of device.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        I2C Slave object on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_spiFlags"></a>Class spiFlags </h2>

          <div class="section-description">
          <h3>SPI Flags</h3>
 A set of "macros" (Lua functions) that can be used to assemble the <code>flags</code> parameter
 for the function <code>cSession:openSPI(spichannel, bitrate, flags, name)</code>.<br>
 Here is how flags word is constructed:<br>
 <code>21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0</code><br>
 <code> b  b  b  b  b  b  R  T  n  n  n  n  W  A u2 u1 u0 p2 p1 p0  m1  m0</code><br>
 <ul>
 <li>mode: operation mode: pol * 2 + pha
 <li>cslev: chip select level: p2..p0
 <li>csuse: chip select usage: u2..u0
 <li>interface: interface to use: "main" or "aux"
 <li>wires: wires to use: 4 (bidir) or 3 (unidir)
 <li>masterbytes: 0..15
 <li>txendian: transmit endian: "big" or "little"
 <li>rxendian: treceive endian: "big" or "little"
 <li>wordsize: word size: 0..32
</ul>
 NOTE: wrong constructed flag values are not detected before using in call to cSession:openSPI(...).
          </div>
    <dl class="function">
    <dt>
    <a name = "spiFlags:mode"></a>
    <strong>spiFlags:mode (pol, pha)</strong>
    </dt>
    <dd>
    SPI Mode: 0..3 => 00, 01, 10, 11 = (pol, pha)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">pol</span>

        </li>
        <li><span class="parameter">pha</span>

        </li>
    </ul>





</dd>
    <dt>
    <a name = "spiFlags:cslev"></a>
    <strong>spiFlags:cslev (cs2, cs1, cs0)</strong>
    </dt>
    <dd>
    SPI chip select level: 0..7 => 000, 001, ..., 111 = (cs2, cs1, cs0)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cs2</span>

        </li>
        <li><span class="parameter">cs1</span>

        </li>
        <li><span class="parameter">cs0</span>

        </li>
    </ul>





</dd>
    <dt>
    <a name = "spiFlags:csuse"></a>
    <strong>spiFlags:csuse (cs2, cs1, cs0)</strong>
    </dt>
    <dd>
    SPI chip select usage: 0..7 => 000, 001, ..., 111 = (cs2, cs1, cs0)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cs2</span>

        </li>
        <li><span class="parameter">cs1</span>

        </li>
        <li><span class="parameter">cs0</span>

        </li>
    </ul>





</dd>
    <dt>
    <a name = "spiFlags:interface"></a>
    <strong>spiFlags:interface (val)</strong>
    </dt>
    <dd>
    SPI interface: "aux" or "main"


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">val</span>

        </li>
    </ul>





</dd>
    <dt>
    <a name = "spiFlags:wires"></a>
    <strong>spiFlags:wires (val)</strong>
    </dt>
    <dd>
    SPI 3 wire: 3 or 4


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">val</span>

        </li>
    </ul>





</dd>
    <dt>
    <a name = "spiFlags:masterbytes"></a>
    <strong>spiFlags:masterbytes (val)</strong>
    </dt>
    <dd>
    SPI MOSI bytes to transmit before changing to MISO: 0..15


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">val</span>

        </li>
    </ul>





</dd>
    <dt>
    <a name = "spiFlags:txendian"></a>
    <strong>spiFlags:txendian (val)</strong>
    </dt>
    <dd>
    SPI transmit endianess: "big" or "little"


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">val</span>

        </li>
    </ul>





</dd>
    <dt>
    <a name = "spiFlags:rxendian"></a>
    <strong>spiFlags:rxendian (val)</strong>
    </dt>
    <dd>
    SPI receive endianess: "big" or "little"


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">val</span>

        </li>
    </ul>





</dd>
    <dt>
    <a name = "spiFlags:wordsize"></a>
    <strong>spiFlags:wordsize (val)</strong>
    </dt>
    <dd>
    SPI word size: 0 => 1 Byte, 1..8 => 8 bits per char, 9..16 => 16 bits per char, 32 bits per char


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">val</span>

        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Module_functions"></a>Module functions </h2>

          <div class="section-description">

 The pigpio module provides the following functions in the modules name space:
 <code>open()</code> - opens a session with local or remote host.<br>
 <code>tick()</code> - returns hosts tick time in microseconds.<br>
 <code>time()</code> - returns hosts time in seconcs sincd last epoche a floating point.<br>
 <code>getEventStats()</code> - returns event statistics.<br>
 <code>clearEventStats()</code> - clears event statistics.<br>
 <code>wait()</code> - wait a certain time with possibility for lua event callbacks.<br>
 <code>busyWait()</code> - wait without any process blocking call.<br>
 <code>perror()</code> - returns a textual description of an error code.<br>
          </div>
    <dl class="function">
    <dt>
    <a name = "open"></a>
    <strong>open (host, port, name)</strong>
    </dt>
    <dd>
    Open a session with given host on given port.  An optional user defined name
 can be defined; if nil a name 'sess-<sess.handle>' is created automatically.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">host</span>
         Hostname of target system. Default: localhost.
        </li>
        <li><span class="parameter">port</span>
         Port to be used. Default: 8888.
        </li>
        <li><span class="parameter">name</span>
         Name of this session (optional).
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Session object of class cSession.
    </ol>




</dd>
    <dt>
    <a name = "wait"></a>
    <strong>wait (t, ts)</strong>
    </dt>
    <dd>
    Wait for a while.
 This function blocks in time chunks allowing Lua callbacks to be called
 by the pigpiod library. The given waiting time t is split into n=t/ts
 blocking calls to gpio.sleep(ts) with ts = 1 ms by default.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
         time to sleep in seconds.
        </li>
        <li><span class="parameter">ts</span>
         time step to use - optional.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true
    </ol>




</dd>
    <dt>
    <a name = "busyWait"></a>
    <strong>busyWait (t)</strong>
    </dt>
    <dd>
    Busy wait for a while.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
         time to sleep in seconds.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true.
    </ol>




</dd>
    <dt>
    <a name = "info"></a>
    <strong>info ()</strong>
    </dt>
    <dd>
    Returns info string.



    <h3>Returns:</h3>
    <ol>

        Info string.
    </ol>




</dd>
    <dt>
    <a name = "getEventStats"></a>
    <strong>getEventStats ()</strong>
    </dt>
    <dd>
    Get event handling statistics in the form.
 <code>{drop = DROP, maxcount = MAXCOUNT}</code>
 The function captures a snapshot.



    <h3>Returns:</h3>
    <ol>

        Event statics on success, nil + errormsg on failure
    </ol>




</dd>
    <dt>
    <a name = "clearEventStats"></a>
    <strong>clearEventStats ()</strong>
    </dt>
    <dd>
    Clear event statistics.



    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "startThread"></a>
    <strong>startThread (code, name, ...)</strong>
    </dt>
    <dd>
    Start a new thrad.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">code</span>
         Lua code in a string.
        </li>
        <li><span class="parameter">name</span>
         Name of the thread.
        </li>
        <li><span class="parameter">...</span>
         Paramters passed to the given Lua code as arguments.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        pthread user data on success, nil + errormsg on failure.
    </ol>




</dd>
    <dt>
    <a name = "stopThread"></a>
    <strong>stopThread (pthread)</strong>
    </dt>
    <dd>
    Stop given thread.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">pthread</span>
         Name or pthread userdata of thread.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil + errormsg on failure.
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2018-12-23 23:36:45 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
